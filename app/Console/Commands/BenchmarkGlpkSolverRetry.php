<?php

// Copilot - Pending review

namespace App\Console\Commands;

use App\Services\Lottery\DataObjects\LotterySpec;

/**
 * Retry failed GLPK benchmark cases from a previous benchmark run.
 *
 * This command parses CSV files generated by benchmark:glpk, extracts cases that failed,
 * timed out, or were marked as infeasible, and re-runs them with configurable iterations.
 *
 * Purpose:
 *   - Verify non-deterministic failures (e.g., random jitter causing intermittent infeasibility)
 *   - Test increased timeout values on previously timed-out cases
 *   - Collect statistics on failure consistency (does same spec fail 100% or 1% of the time?)
 *
 * Usage:
 *   # Retry all failures from a specific CSV file
 *   php artisan benchmark:glpk:retry storage/benchmarks/glpk_random_5.csv --iterations=100
 *
 *   # Retry failures matching size/scenario (auto-finds most recent CSV)
 *   php artisan benchmark:glpk:retry --size=20 --scenario=random --iterations=50 --timeout=60
 *
 * Input CSV format (auto-detected from benchmark:glpk):
 *   size,scenario,iteration,time_ms,status,error,spec_hash,result
 *
 * Output:
 *   Creates new CSV with "_retry" suffix containing re-execution results.
 *   Original failure specs are preserved and re-tested multiple times per --iterations.
 *
 * Workflow:
 *   1. Run benchmark:glpk to collect initial data (may include TIMEOUT/INFEASIBLE/FAILED)
 *   2. Run this command on the output CSV to retry problematic cases
 *   3. Compare original vs retry results to determine if failures are deterministic
 *   4. If failures persist, investigate GLPK model/data files (logged on error)
 *
 * @see BenchmarkGlpkSolver For generating initial benchmark data
 * @see documentation/ai/lottery/GLPK_BENCHMARKS.md For detailed benchmarking methodology
 */
class BenchmarkGlpkSolverRetry extends BenchmarkGlpkBase
{
    protected $signature = 'benchmark:glpk:retry
                            {file? : Path to CSV file with failures to retry}
                            {--size= : Problem size (NxN)}
                            {--scenario= : Scenario type (identical|random|opposite|realistic)}
                            {--iterations=1 : Number of times to retry each failed case}
                            {--only= : Comma-separated list of iteration numbers to retry (e.g., 1,3,5)}
                            {--timeout=30 : Solver timeout in seconds}';

    protected $description = 'Retry failed GLPK benchmark cases from a previous run';

    public function handle(): int
    {
        $timeout = (int) $this->option('timeout');
        $iterations = (int) $this->option('iterations');
        $onlyIterations = $this->parseOnlyIterations();

        $inputFile = $this->resolveInputFile();

        if (!file_exists($inputFile)) {
            $this->error("File not found: {$inputFile}");
            return self::FAILURE;
        }

        $failures = $this->loadFailures($inputFile, $onlyIterations);

        if (empty($failures)) {
            $this->info("No failures found in {$inputFile}");
            return self::SUCCESS;
        }

        $outputPath = $this->getRetryOutputPath($inputFile);

        $this->configureSolver($timeout);
        $this->initializeSolver();
        $this->createOutputFile($outputPath);

        $totalRetries = count($failures) * $iterations;
        $this->info("Retrying " . count($failures) . " failed cases x{$iterations} iterations = {$totalRetries} total retries");
        $this->info("Output file: {$outputPath}");
        $this->newLine();

        $this->retryFailures($failures, $iterations);

        $this->cleanup();

        $this->newLine();
        $this->info("Retry results saved to: {$outputPath}");

        return self::SUCCESS;
    }

    private function resolveInputFile(): string
    {
        $file = $this->argument('file');

        if ($file) {
            return $file;
        }

        $size = $this->option('size');
        $scenario = $this->option('scenario');

        if (empty($size) || empty($scenario)) {
            $this->error('Either provide a file path or both --size and --scenario options');
            exit(1);
        }

        return storage_path("benchmarks/glpk_{$scenario}_{$size}.csv");
    }

    private function getRetryOutputPath(string $inputFile): string
    {
        $pathInfo = pathinfo($inputFile);
        $directory = $pathInfo['dirname'];
        $filename = $pathInfo['filename'];
        $extension = $pathInfo['extension'] ?? 'csv';

        return "{$directory}/{$filename}_retry.{$extension}";
    }

    private function parseOnlyIterations(): ?array
    {
        $only = $this->option('only');

        if (empty($only)) {
            return null;
        }

        return array_map('intval', explode(',', $only));
    }

    private function loadFailures(string $file, ?array $onlyIterations = null): array
    {
        $failures = [];
        $handle = fopen($file, 'r');

        if ($handle === false) {
            return [];
        }

        // Skip header
        fgetcsv($handle);

        while (($row = fgetcsv($handle)) !== false) {
            if (count($row) < 7) {
                continue;
            }

            [$size, $scenario, $iteration, $timeMs, $status, $error, $specHash] = $row;

            // Only retry failures, timeouts, and infeasible cases
            if (in_array($status, ['FAILED', 'TIMEOUT', 'INFEASIBLE']) && !empty($specHash)) {
                $iterationNum = (int) $iteration;

                // Filter by iteration numbers if --only was specified
                if ($onlyIterations !== null && !in_array($iterationNum, $onlyIterations)) {
                    continue;
                }

                $failures[] = [
                    'size'      => (int) $size,
                    'scenario'  => $scenario,
                    'iteration' => $iterationNum,
                    'spec'      => $specHash,
                ];
            }
        }

        fclose($handle);

        return $failures;
    }

    private function retryFailures(array $failures, int $iterations): void
    {
        $this->displayTableHeader();

        foreach ($failures as $index => $failure) {
            for ($i = 1; $i <= $iterations; $i++) {
                $this->retryFailure($failure, $i);
            }
        }

        $this->displaySummary();
    }

    private function retryFailure(array $failure, int $retryNumber): void
    {
        $spec = $this->decodeSpec($failure['spec']);

        if ($spec === null) {
            $this->error("Failed to decode spec for iteration {$failure['iteration']}");
            return;
        }

        $result = $this->executeSolver($spec);

        $this->recordResult(
            $failure['size'],
            $failure['scenario'],
            $failure['iteration'],
            $result,
            $spec
        );
    }

    private function decodeSpec(string $specHash): ?LotterySpec
    {
        $data = json_decode($specHash, true);

        if ($data === null) {
            $this->warn("JSON decode failed: " . json_last_error_msg());
            $this->warn("Spec hash (first 200 chars): " . substr($specHash, 0, 200));
            return null;
        }

        // Accept 'preferences' as primary, 'families' for backwards compatibility
        $preferences = $data['preferences'] ?? $data['families'] ?? null;
        $units = $data['units'] ?? null;

        if ($preferences === null || $units === null) {
            $this->warn("Missing units or preferences in decoded data");
            $this->warn("Available keys: " . implode(', ', array_keys($data)));
            return null;
        }

        return new LotterySpec($preferences, $units);
    }
}
